(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{339:function(t,n,r){"use strict";r.r(n);var a=r(0),e=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"python绘制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#python绘制"}},[t._v("#")]),t._v(" Python绘制")]),t._v(" "),n("h3",{attrs:{id:"❤文本绘制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#❤文本绘制"}},[t._v("#")]),t._v(" ❤文本绘制")]),t._v(" "),n("h4",{attrs:{id:"预览"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#预览"}},[t._v("#")]),t._v(" 预览")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("     *\n    ***\n   *****\n  *******\n *********\n***********\n     |\n     |\n\n")])])]),n("h4",{attrs:{id:"思路"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("第一行n个空格1个雪花字符\n第二行n-1个空格3个雪花字符\n第三行n-2个空格5个雪花字符\n以此类推,知道空格为0的时候停止\n最后再画树干\n")])])]),n("h4",{attrs:{id:"代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码"}},[t._v("#")]),t._v(" 代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("# 定义初始打印空格数\nn=10\n# 定义初始打印雪花字符数\nword=1\n# 定义树干长度\ntreeLen=n//2\n# 打印个小鳄鱼助助兴\nprint(\"\"\"\n                    __  __\n       _ _        /_@)_@) \\          /^^\\ /^\\ /^^\\_\n    _/oo \\____/~''. . .  '~\\       /'\\''  ~ ''~~' -'\\_\n   / '.'. ~.~.~.       .'    ~ |     /'\\~~..''''.'' ''  ~\\_\n  ('_'_'_'_'_'_'_'_  ' :   '     \\_/' '.''  . '.   .''  '.  ~\\_\n  ~V~V~V~V  \\   ~\\  '' '~  '   '' ~   `   ~  ''   ~\\_\n    /\\~/\\~/\\~/\\~/|/  '   ''  _   ' ~ ''  '    ~  '' __  '  ..  \\_\n <-- --- ---.---.--/'   ''   /'  '\\_ '' ': ~ ;;''    ' /''; \\ ;'''''' '' ~\\ _\n    \\~ '. . : .:: ~. :.  /_'''_'' \\_' :'''_ : _ ''/''_' '_ \\:_ '''' #''..\\/\\/\\/~/\\~ ''~~~~~O\n ~~ \\-~ `---~~~---- \\(_)(_)(_)/ ~ ~~' ~\\(_)(_)(_)\\_~_~_~_~_~/˜¤¹\n\"\"\")\n\n\n# 打印树头,雪花符号数每次+2,空格每次-1\nwhile n>=0:\n    print(' '*n,'*'*word,sep='')\n    word+=2\n    n-=1\n# 打印树干\n# 树干位置在树中间,因为打印树头最后一行空格数为0,雪花符号数为\n# word(奇数),所以中间位置是word//2+1,所以|前空格数为word//2\nfor i in range(treeLen):\n    print(' '*(word//2),'|',sep='')\n")])])]),n("h3",{attrs:{id:"turtle"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#turtle"}},[t._v("#")]),t._v(" turtle")]),t._v(" "),n("p",[t._v("我们上面用文本完成了简单圣诞树的绘制,接下来我们使用turtle绘制,turtle是python的内置库,属于入门级的图形绘制函数库,我们可以很容易使用它,如果你对turtle还不了解,不妨先看看这个"),n("a",{attrs:{href:"https://blog.csdn.net/sandalphon4869/article/details/99443949",target:"_blank",rel:"noopener noreferrer"}},[t._v("turtle入门"),n("OutboundLink")],1)]),t._v(" "),n("h3",{attrs:{id:"演示"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#演示"}},[t._v("#")]),t._v(" 演示")]),t._v(" "),n("p",[n("img",{attrs:{src:"/images/1.png",alt:"alt 演示"}})]),t._v(" "),n("h3",{attrs:{id:"代码-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码-2"}},[t._v("#")]),t._v(" 代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import turtle\n# 设置屏幕大小\nimport random\nscreen = turtle.Screen()\nscreen.setup(800,600)\n# 设置画笔大小\nturtle.pensize(10)\n# 隐藏笔头\nturtle.hideturtle()\n# 设置绘制速度\nturtle.speed('fastest')\n''':argument\n下面函数是用来绘制圣诞树\nx,y:第一个星星的坐标\nrows:绘制的星星行数\ntagramStep:星星的间距\ntagramLength:星星的边长\ntagramCount:初始绘制星星的个数\n'''\ndef drawTree(x,y,rows,tagramStep=5,tagramLength=30,tagramCount=1):\n    # 提前计算树干x坐标,因为之后x会变化\n    tx=x\n    # rows代要绘制几行星星\n    for row in range(rows):\n        # 拷贝一份x用来绘制星星\n        rowX=x\n        # 绘制星星\n        for count in range(tagramCount):\n            # 随机画笔颜色\n            turtle.color(random.choice(['red','green','blue','yellow','orange']))\n            turtle.penup()\n            # 绘制的初始位置\n            turtle.goto(rowX, y)\n            turtle.pendown()\n            # 使箭头朝右方便绘制\n            turtle.seth(0)\n            # 随机数,如果为1就画圆,反之画星星\n            if random.choice([0,1]):\n                turtle.circle(tagramLength//2)\n            else:\n                # 先向后半个长度再回来,使得星星横坐标中心点在rowX位置\n                turtle.back(tagramLength//2)\n                turtle.forward(tagramLength)\n                # 接下来重复旋转前进\n                for i in range(4):\n                    turtle.right(144)  # 顺时针旋转144°\n                    turtle.forward(tagramLength)\n            # 绘制完一颗星星后,计算下一个星星的初始位置,因为还是当前行,所以y坐标不变\n            rowX+=(tagramLength+tagramStep)\n        # 绘制完一行后,计算第二行的初始星星坐标\n        # 横纵坐标减去一个星星长度加间距\n        x-=(tagramLength+tagramStep)\n        y-=(tagramLength+tagramStep)\n        # 星星个数增加2\n        tagramCount+=2\n    # 绘制树干\n    turtle.penup()\n    turtle.goto(tx,y)\n    turtle.seth(-90)\n    turtle.pendown()\n    turtle.forward(rows*tagramLength)\n    turtle.down()\n    \n\ndrawTree(0,270,8,tagramLength=20,tagramStep=20)\nturtle.mainloop()\n")])])])])}),[],!1,null,null,null);n.default=e.exports}}]);